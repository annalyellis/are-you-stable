<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Balance Quiz & Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="style.css" />
  <script src="https://unpkg.com/scrollama"></script>

  
  <style>
  </style>
</head>
<header>
  <nav>
  </nav>
</header>
<body>
  <div class="progress-bar">
    <div id="progress-fill" class="progress-fill"></div>
  </div>

  <div id="quizContainer">

    <div id="step0" class="step active">
      <h2>Welcome to the Balance Assessment!</h2>
      <p>This quiz will assess your balance so we can provide you with personalized insights. It involves several steps, including questions about your physical activity and a simple motor test.
      </p>
      <p>It will result in a Mini Balance Evaluation Systems Test (Mini BES-test) score, similar to the ones patients in our dataset received through a series of physical exercises. We will predict yours through the other questions they answered.</p>
      <div class="navigation-buttons">
        <button id="startQuizBtn" onclick="goToStep(1)">Start Quiz</button>
      </div>
    </div>

    <div id="step1" class="step">
      <h2>1. Personal Information</h2>
      <div class="question">
        <label for="age">Age:</label>
        <input type="number" id="age" name="age" min="1" max="120" required>
      </div>
      <div class="question">
        <label for="gender">Gender:</label>
        <select id="gender" name="gender" required>
          <option value="">Select</option>
          <option value="male">Male</option>
          <option value="female">Female</option>
          <option value="other">Other</option>
        </select>
      </div>
      <div class="question">
        <label for="height">Height (inches):</label>
        <input type="number" id="height" name="height" min="20" max="100" step="0.1" required>
      </div>
      <div class="question">
        <label for="weight">Weight (pounds):</label>
        <input type="number" id="weight" name="weight" min="50" max="1000" step="0.1" required>
      </div>
      <div class="navigation-buttons">
        <button id="prevBtn1" onclick="prevStep()" style="display: none;">Previous</button>
        <button id="nextBtn1" onclick="nextStep()">Next</button>
      </div>
    </div>

    <div id="step2" class="step">
      <h2>2. Falls Efficacy Scale - International (FES-I)</h2>
      <p>Please indicate your level of concern about falling during the following activities:</p>
      <div id="fesQuestions">
        </div>
      <div class="navigation-buttons">
        <button id="prevBtn2" onclick="prevStep()">Previous</button>
        <button id="nextBtn2" onclick="nextStep()">Next</button>
      </div>
    </div>

    <div id="step3" class="step">
      <h2>3. International Physical Activity Questionnaire (IPAQ)</h2>
      <div class="question">
        <label for="ipaq1a">In the last 7 days, on how many days did you do **vigorous** physical activities like heavy lifting, digging, aerobics, or fast bicycling?</label>
        <input type="number" id="ipaq1a" name="ipaq1a" min="0" max="7" required>
      </div>
      <div class="question">
        <label for="ipaq1b">How much time did you spend on one of those days doing vigorous physical activities? (minutes per day)</label>
        <input type="number" id="ipaq1b" name="ipaq1b" min="0" required>
      </div>
      <div class="question">
        <label for="ipaq2a">In the last 7 days, on how many days did you do **moderate** physical activities like carrying light loads, bicycling at a regular pace, or doubles tennis? (Don't include walking)</label>
        <input type="number" id="ipaq2a" name="ipaq2a" min="0" max="7" required>
      </div>
      <div class="question">
        <label for="ipaq2b">How much time did you spend on one of those days doing moderate physical activities? (minutes per day)</label>
        <input type="number" id="ipaq2b" name="ipaq2b" min="0" required>
      </div>
      <div class="navigation-buttons">
        <button id="prevBtn3" onclick="prevStep()">Previous</button>
        <button id="nextBtn3" onclick="nextStep()">Next</button>
      </div>
    </div>

    <div id="step4" class="step">
      <h2>4. Trail Making Test (TMT) - Part A (Numbers)</h2>
      <p>Click on the numbers in ascending order (1, 2, 3, ...). The timer starts when you click 'Start'.</p>
      <div class="tmt-grid" id="tmtGrid">
        </div>
      <div class="tmt-timer" id="tmtTimer">Ready to start</div>
      <div class="navigation-buttons">
        <button id="tmtStartBtn" onclick="startTMT()">Start Test</button>
        <button id="prevBtn4" onclick="prevStep()">Previous</button>
        <button id="tmtNextBtn" onclick="nextStep()" disabled>Next</button>
      </div>
    </div>

    <div id="step5" class="step">
      <h2>5. Submit Assessment</h2>
      <p>Click 'Submit' to calculate your balance score and see your personalized results.</p>
      <div class="navigation-buttons">
        <button id="prevBtn5" onclick="prevStep()">Previous</button>
        <button id="submitBtn" onclick="calculateResults()">Submit</button>
      </div>
    </div>
  </div>

  <div id="mainContent">
    <div id="resultsPane">
        <button class="toggle-button" onclick="toggleResultsPane()">Minimize Results</button>
        <h2>Your Predicted Mini-BESTest Score: <span id="predictedScore"></span></h2>
        <div id="scoreInterpretation"></div>
        <div id="recommendations"></div>
        <div id="comparisonChart"></div> <div style="text-align: center; margin-top: 20px;">
            <button class="download-button" onclick="downloadScore()">Download My Score</button>
            <a href="#" id="downloadResultsBtn" class="download-button" onclick="downloadResults()">Download All Results (JSON)</a>
            <button class="download-button" onclick="resetAssessment()">Start New Assessment</button>
        </div>
    </div>
    <div id="visualizationArea">
        <div id="viz1" class="viz-container">
            <h2>Balance Over Time (By Gender)</h2>
            <div class="viz-content">
                <p>This graph illustrates the trend in balance performance one could experience throughout their lifetime.
                    It is based on the Best_t score, the same score you recieved by taking the quiz. Scroll to find out how your balance might change over time!
                </p>
                <svg width="100%" height="300"></svg> <p>Consider how you compare to others your age and gender. Remember that consistent activity often leads to
                    more stable balance over time.
                </p>
            </div>
        </div>
        <div id="viz2" class="viz-container">
          <h2>Does Height Impact Balance?</h2>
          <div class="viz-content">
              <p>Exploring the relationship between participant height and Mini-BESTest scores</p>
              <svg width="100%" height="300"></svg>
              <p>This visualization explores the relationship between height (in inches) and balance ability as measured by the Mini-BESTest. 
                The scatter plot shows individual data points, while the red regression line indicates a trend: taller individuals tend to score slightly higher on the Mini-BESTest. 
                The shaded area around the line represents the 95% confidence interval. A Pearson correlation coefficient of 0.50 suggests a weak positive relationship between height and balance performance. However, variability in scores at all heights indicates that height alone does not fully determine balance ability</p>
          </div>
        </div>

        <div id="viz3" class="viz-container">
            <h2>How to Improve Your Balance: More Exercise</h2>
            <div class="viz-content">
                <p>This visualization shows us that, on average, more minutes of moderate exercise is better for your balance.</p>
                <svg width="100%" height="300"></svg>
                <p>Where are you on the graph? Incorporating more moderate exercise into our daily lives can help us maintain stability as we age.</p>
            </div>
        </div>
        <div id="viz4" class="viz-container">
            <h2>How to Improve Your Balance: Better Shoes</h2>
            <div class="viz-content">
                <p>How do shoes impact your balance? For good long-term balance it is important to consider which shoes can lead to long term stability. What kind of shoes do you wear?</p>
                <label for="footwearSelect"><strong>Select your most worn footwear:</strong></label>
                <select id="footwearSelect">
                  <option value="">-- Select Footwear --</option>
                </select>
                <svg width="100%" height="550"></svg>
                <p>It looks like shoes with higher support, such as zero-drop tennis shoes or boots lead to good balance. Yet, orthopedic shoes perform poorly 
                  while flip flops perform relatively well. This is due to the nature of our dataset - elderly people might be more inclined to wear orthopedic
                  shoes while younger people might be more inclined to wear flip-flops.
                </p>
            </div>
        </div>
        <div id="viz5" class="viz-container">
          <h2>How Lifestyle Choices Change Your Balance Over Time</h2>
          <div class="viz-content">
            <p>This chart compares two scenarios: "Average Joe if he continued his normal habits" vs. "Average Joe if he engaged in more exercise and wore better footwear." The lines show how balance scores change with age for each group. Scroll to see what happens to Joe if he takes our advice!</p>
            <svg width="100%" height="350"></svg>
          </div>
        </div>
        
        <div id="final" >
          <p>You’ve just taken a meaningful step towards understanding your body. Balance isn’t just about standing still - it’s about adapting and moving forward, both physically and mentally. Whether your quiz score surprised you or validated your efforts, the important thing is that you’re here and ready to take action. 
            Remember: balance is only a skill. And like any skill, it can be nurtured. Taking small, consistent steps - whether it’s exercising, wearing more supportive footwear, or simply bringing more awareness - can make a real difference over time.
          </p>
        </div>
        <div id="falling">
          <h1>It’s not about falling - it’s about learning how to get back up stronger.</h1>
        </div>
      </div>
  </div>

  <script>
    
    let currentStep = 0;
    let assessmentData = {};
    let tmtStartTime = null;
    let tmtCurrentNumber = 1;
    let tmtCompleted = false;
    let finalPredictedScore = null; 
    let autoTransitionTimeout; 

    // FES-I Questions - A static list of questions for the FES-I section
    const fesQuestions = [
        "Cleaning the house (e.g. sweep, vacuum, or dust)",
        "Getting dressed or un-dressed",
        "Preparing simple meals",
        "Taking a bath or shower",
        "Going to the shop",
        "Getting in or out of a chair",
        "Going up or down stairs",
        "Walking around the house",
        "Walking on a slippery surface (e.g. wet floor, ice)",
        "Walking on an uneven surface (e.g. stony path, grass)",
        "Walking in a place with crowds (e.g. shopping center, street)",
        "Walking up or down a slope",
        "Visiting friends or relatives",
        "Going to a place with stairs or steps",
        "Going for a social event (e.g. club, religious meeting, party)",
        "Going to the doctor's clinic or hospital"
    ];


    function startQuizFromIntro() {
        // Hide the intro section
        document.getElementById('introSection').style.display = 'none';
        
        // Show the quiz container
        document.getElementById('quizContainer').style.display = 'block';
        
        // Make sure we're at step 0 (welcome page)
        goToStep(0);
    }

    /**
     * Initializes the quiz on page load.
     * Sets the initial step to the welcome screen and prepares dynamic elements.
     */
    window.onload = function() {
        //goToStep(0); // Show the welcome step first
        initializeFESQuestions();
        initializeTMT();
        // Initially hide the main content split view using CSS directly, not JS here
        // The CSS for #mainContent and #visualizationArea now includes display: none; by default
        document.getElementById('introSection').style.display = 'block';
        document.getElementById('quizContainer').style.display = 'none';

        document.getElementById('toQuizbtn').addEventListener('click', startQuizFromIntro);
    };

    /**
     * Navigates to a specific quiz step.
     * @param {number} stepNum - The number of the step to go to.
     */
    function goToStep(stepNum) {
        document.querySelectorAll('.step').forEach(step => step.classList.remove('active'));
        currentStep = stepNum;
        document.getElementById(`step${stepNum}`).classList.add('active');
        updateProgress();

        // Manage navigation button visibility
        const prevBtns = [
            document.getElementById('prevBtn1'),
            document.getElementById('prevBtn2'),
            document.getElementById('prevBtn3'),
            document.getElementById('prevBtn4'),
            document.getElementById('prevBtn5')
        ];
        prevBtns.forEach(btn => {
            if (btn) { // Check if the button exists
                btn.style.display = (currentStep > 0 && currentStep <= 5) ? 'inline-block' : 'none';
            }
        });
    }

    /**
     * Updates the progress bar based on the current quiz step.
     */
     function updateProgress() {
    const totalSteps = 5; // Total assessment steps (1 to 5)
    const progress = ((currentStep - 1) / (totalSteps - 1)) * 100;
    document.getElementById('progress-fill').style.width = `${Math.max(0, progress)}%`;
}

    /**
     * Dynamically creates and displays the FES-I questions.
     * Pre-selects options if data already exists (e.g., on 'Previous' button click).
     */
    function initializeFESQuestions() {
        const container = document.getElementById('fesQuestions');
        container.innerHTML = ''; // Clear existing questions
        fesQuestions.forEach((question, index) => {
            const questionId = `fes${index + 1}`;
            const questionDiv = document.createElement('div');
            questionDiv.className = 'question';
            questionDiv.innerHTML = `
                <label>${index + 1}. ${question}</label>
                <div class="likert-scale">
                    <div class="likert-option" data-value="1" onclick="selectLikert(this, '${questionId}', 1)">
                        <div>Not at all concerned</div>
                        <div><strong>1</strong></div>
                    </div>
                    <div class="likert-option" data-value="2" onclick="selectLikert(this, '${questionId}', 2)">
                        <div>Somewhat concerned</div>
                        <div><strong>2</strong></div>
                    </div>
                    <div class="likert-option" data-value="3" onclick="selectLikert(this, '${questionId}', 3)">
                        <div>Fairly concerned</div>
                        <div><strong>3</strong></div>
                    </div>
                    <div class="likert-option" data-value="4" onclick="selectLikert(this, '${questionId}', 4)">
                        <div>Very concerned</div>
                        <div><strong>4</strong></div>
                    </div>
                </div>
            `;
            container.appendChild(questionDiv);

            // If a value is already stored, pre-select the option
            if (assessmentData[questionId]) {
                const selectedOption = questionDiv.querySelector(`.likert-option[data-value="${assessmentData[questionId]}"]`);
                if (selectedOption) {
                    selectedOption.classList.add('selected');
                }
            }
        });
    }

    /**
     * Handles the selection of a Likert scale option.
     * Stores the selected value in `assessmentData`.
     * @param {HTMLElement} element - The clicked Likert option element.
     * @param {string} questionId - The ID of the question (e.g., 'fes1').
     * @param {number} value - The numerical value of the selected option.
     */
    function selectLikert(element, questionId, value) {
        element.parentNode.querySelectorAll('.likert-option').forEach(opt => {
            opt.classList.remove('selected');
        });
        element.classList.add('selected');
        assessmentData[questionId] = value;
    }

    /**
     * Converts height from inches to centimeters and weight from pounds to kilograms.
     * @param {number} heightInInches - Height in inches.
     * @param {number} weightInPounds - Weight in pounds.
     * @returns {{heightCm: number, weightKg: number}} - Object with converted values.
     */
    function convertToMetric(heightInInches, weightInPounds) {
        const heightCm = heightInInches * 2.54;
        const weightKg = weightInPounds * 0.453592;
        return { heightCm, weightKg };
    }

    /**
     * Initializes the Trail Making Test (TMT) grid.
     * Generates and shuffles numbers for the test.
     */
    function initializeTMT() {
        const grid = document.getElementById('tmtGrid');
        grid.innerHTML = ''; // Clear existing circles
        const numbers = Array.from({length: 13}, (_, i) => i + 1); // Numbers 1 to 13

        // Shuffle positions for a random layout
        const shuffled = numbers.sort(() => Math.random() - 0.5);

        shuffled.forEach(num => {
            const circle = document.createElement('div');
            circle.className = 'tmt-circle';
            circle.textContent = num;
            circle.dataset.number = num;
            circle.onclick = () => clickTMTNumber(num, circle);
            grid.appendChild(circle);
        });

        // Reset TMT state for re-initialization
        document.getElementById('tmtTimer').textContent = 'Ready to start';
        document.getElementById('tmtStartBtn').style.display = 'inline-block';
        document.getElementById('tmtNextBtn').disabled = true;
    }

    /**
     * Starts the Trail Making Test timer and highlights the first number.
     */
    function startTMT() {
        tmtStartTime = Date.now();
        tmtCurrentNumber = 1;
        tmtCompleted = false;

        document.getElementById('tmtStartBtn').style.display = 'none';
        const firstCircle = document.querySelector('[data-number="1"]');
        if (firstCircle) {
            firstCircle.classList.add('current');
        }

        updateTMTTimer();
    }

    /**
     * Updates the TMT timer display.
     * Uses `requestAnimationFrame` for smooth updates.
     */
    function updateTMTTimer() {
        if (!tmtStartTime || tmtCompleted) return;

        const elapsed = (Date.now() - tmtStartTime) / 1000;
        document.getElementById('tmtTimer').textContent = `Time: ${elapsed.toFixed(1)}s`;

        requestAnimationFrame(updateTMTTimer);
    }

    /**
     * Handles clicks on TMT numbers.
     * Validates if the correct number is clicked and tracks progress.
     * @param {number} number - The number on the clicked circle.
     * @param {HTMLElement} element - The clicked circle element.
     */
    function clickTMTNumber(number, element) {
        if (!tmtStartTime || tmtCompleted) return;

        if (number === tmtCurrentNumber) {
            element.classList.remove('current');
            element.classList.add('completed');

            tmtCurrentNumber++;

            if (tmtCurrentNumber <= 13) {
                const nextCircle = document.querySelector(`[data-number="${tmtCurrentNumber}"]`);
                if (nextCircle) {
                    nextCircle.classList.add('current');
                }
            } else {
                // Test completed
                tmtCompleted = true;
                const totalTime = (Date.now() - tmtStartTime) / 1000;
                assessmentData.tmtTime = totalTime;

                document.getElementById('tmtTimer').textContent = `Completed in ${totalTime.toFixed(1)}s`;
                document.getElementById('tmtNextBtn').disabled = false;
            }
        }
    }

    /**
     * Moves to the next quiz step after validating the current step.
     */
    function nextStep() {
        if (!validateCurrentStep()) {
            alert('Please complete all required fields for this step.');
            return;
        }

        collectCurrentStepData();

        document.getElementById(`step${currentStep}`).classList.remove('active');
        currentStep++;
        goToStep(currentStep);

        if (currentStep > 5) { // If it's past the last quiz step, calculate results
            calculateResults();
        }
    }

    /**
     * Moves to the previous quiz step.
     */
    function prevStep() {
        document.getElementById(`step${currentStep}`).classList.remove('active');
        currentStep--;
        goToStep(currentStep);
    }

    /**
     * Validates that all required fields for the current step are filled.
     * @returns {boolean} - True if validation passes, false otherwise.
     */
    function validateCurrentStep() {
        if (currentStep === 1) {
            return document.getElementById('age').value &&
                   document.getElementById('gender').value &&
                   document.getElementById('height').value &&
                   document.getElementById('weight').value;
        } else if (currentStep === 2) {
            // Check if all FES questions have a selected value
            return fesQuestions.every((_, i) => assessmentData[`fes${i + 1}`] !== undefined);
        } else if (currentStep === 3) {
            return document.getElementById('ipaq1a').value !== '' &&
                   document.getElementById('ipaq1b').value !== '' &&
                   document.getElementById('ipaq2a').value !== '' &&
                   document.getElementById('ipaq2b').value !== '';
        } else if (currentStep === 4) {
            return tmtCompleted;
        }
        return true;
    }

    /**
     * Collects data from the current quiz step and stores it in `assessmentData`.
     */
    function collectCurrentStepData() {
        if (currentStep === 1) {
            assessmentData.age = parseInt(document.getElementById('age').value);
            assessmentData.gender = document.getElementById('gender').value;

            const heightInches = parseFloat(document.getElementById('height').value);
            const weightPounds = parseFloat(document.getElementById('weight').value);

            // Convert to metric
            const { heightCm, weightKg } = convertToMetric(heightInches, weightPounds);

            // Save converted values
            assessmentData.height = heightCm;
            assessmentData.weight = weightKg;
            assessmentData.bmi = weightKg / ((heightCm / 100) ** 2);

        } else if (currentStep === 3) {
            assessmentData.ipaq1a = parseInt(document.getElementById('ipaq1a').value) || 0;
            assessmentData.ipaq1b = parseInt(document.getElementById('ipaq1b').value) || 0;
            assessmentData.ipaq2a = parseInt(document.getElementById('ipaq2a').value) || 0;
            assessmentData.ipaq2b = parseInt(document.getElementById('ipaq2b').value) || 0;
        }
        // FES data is collected in `selectLikert`
        // TMT data is collected in `clickTMTNumber`
    }

    /**
     * Calculates the predicted Mini-BESTest score based on collected assessment data.
     * This is a simplified prediction model for demonstration purposes.
     */
    function calculateResults() {
        // Calculate FES total score
        let fesTotal = 0;
        fesQuestions.forEach((_, i) => {
            fesTotal += assessmentData[`fes${i + 1}`] || 1; // Default to 1 if not selected
        });
        assessmentData.fesTotal = fesTotal;

        // Calculate IPAQ score (simplified MET calculation)
        // METs: Vigorous = 8, Moderate = 4
        const vigorousMets = assessmentData.ipaq1a * assessmentData.ipaq1b * 8;
        const moderateMets = assessmentData.ipaq2a * assessmentData.ipaq2b * 4;
        assessmentData.ipaqScore = vigorousMets + moderateMets;

        // Predict Mini-BESTest score using simplified model (max 28)
        let predictedScore = 28; // Base score

        // Age factor
        if (assessmentData.age > 65) predictedScore -= 3;
        else if (assessmentData.age > 45) predictedScore -= 1;

        // BMI factor
        if (assessmentData.bmi > 30) predictedScore -= 2;
        else if (assessmentData.bmi < 18.5) predictedScore -= 1;

        // FES factor (higher concern = lower balance)
        // FES-I score ranges from 16 (no concern) to 64 (severe concern).
        if (fesTotal >= 40) predictedScore -= 4; // High concern
        else if (fesTotal >= 30) predictedScore -= 3; // Moderate-high concern
        else if (fesTotal >= 20) predictedScore -= 1; // Moderate concern

        // TMT factor (slower time = lower balance)
        if (assessmentData.tmtTime > 30) predictedScore -= 3;
        else if (assessmentData.tmtTime > 20) predictedScore -= 1;

        // Physical activity factor (higher activity = better balance)
        // IPAQ scores can be large, use thresholds for impact.
        if (assessmentData.ipaqScore > 3000) predictedScore += 2; // Very active
        else if (assessmentData.ipaqScore < 600) predictedScore -= 2; // Low activity

        // Ensure score is within valid range (0-28)
        predictedScore = Math.max(0, Math.min(28, predictedScore));
        finalPredictedScore = predictedScore; // Store for download

        displayResults(predictedScore);
    }

    /**
     * Displays the calculated results as a full-screen page initially.
     * Sets a timeout to transition to the scrollable visualization page after a delay.
     * @param {number} score - The predicted Mini-BESTest score.
     */
    function displayResults(score) {
        const quizContainer = document.getElementById('quizContainer');
        const mainContent = document.getElementById('mainContent');
        const resultsPane = document.getElementById('resultsPane');
        const visualizationArea = document.getElementById('visualizationArea');

        clearTimeout(autoTransitionTimeout); // Clear any existing timeout

        // 1. Fade out quiz container
        quizContainer.style.opacity = 0;
        setTimeout(() => {
            quizContainer.style.display = 'none'; // Hide quiz container after fade out

            // 2. Prepare mainContent for full-screen results
            mainContent.style.display = 'flex'; // Enable flexbox for mainContent
            mainContent.style.opacity = 1; // Fade in mainContent
            mainContent.style.pointerEvents = 'auto'; // Enable interactions

            // Make resultsPane full screen, hide visualizationArea
            resultsPane.classList.add('full-screen-results');
            resultsPane.classList.remove('minimized'); // Ensure it's not minimized
            resultsPane.querySelector('.toggle-button').style.display = 'none'; // Hide toggle button

            // Explicitly hide visualizationArea by changing its display property
            visualizationArea.style.display = 'none'; // THIS IS CRUCIAL TO HIDE VISUALIZATIONS

            // Clear any old visualizations from the visualization area (in case of reset/re-run)
            d3.select('#viz1 svg').selectAll("*").remove();
            d3.select('#viz2 svg').selectAll("*").remove();
            d3.select('#viz3 svg').selectAll("*").remove();
            d3.select('#viz4 svg').selectAll("*").remove();
            d3.select('#viz5 svg').selectAll("*").remove();


            // Clear previous results content in resultsPane
            document.getElementById('predictedScore').textContent = '';
            document.getElementById('scoreInterpretation').innerHTML = '';
            document.getElementById('recommendations').innerHTML = '';
            d3.select('#comparisonChart').selectAll("*").remove(); // Ensure comparison chart SVG is empty


            // Populate results
            document.getElementById('predictedScore').textContent = score.toFixed(1);

            let interpretation = '';
            let recommendations = '';

            if (score >= 24) {
                interpretation = 'Excellent balance! Low fall risk.';
                recommendations = 'Continue your current activity level and consider challenging balance exercises to maintain your excellent balance.';
            } else if (score >= 20) {
                interpretation = 'Good balance with mild impairment.';
                recommendations = 'Consider incorporating more balance training exercises (e.g., tai chi, yoga, standing on one leg) and regular physical activity into your routine to further improve and maintain your balance.';
            } else if (score >= 16) {
                interpretation = 'Moderate balance impairment. Increased fall risk.';
                recommendations = 'Balance training is highly recommended. You should consider consulting a healthcare provider or a physical therapist for a personalized balance assessment and tailored exercise program.';
            } else {
                interpretation = 'Significant balance impairment. High fall risk.';
                recommendations = 'It is strongly advised that you consult with a healthcare provider, such as a doctor or physical therapist, for a comprehensive balance assessment and to develop a specialized training and fall prevention plan.';
            }

            document.getElementById('scoreInterpretation').innerHTML = `<p><strong>${interpretation}</strong></p>`;
            document.getElementById('recommendations').innerHTML = `<h3>Recommendations:</h3><p>${recommendations}</p>`;

            createComparisonChart(score); // Create chart to fill the full-screen results pane

            //     transitionToVizPage();
            // }, 6000); // **Increased delay to 6 seconds**
            // Add this to your results display function
            const exploreButton = document.createElement('button');
            exploreButton.textContent = 'Explore Your Results';
            exploreButton.className = 'explore-results-btn';
            exploreButton.onclick = transitionToVizPage;

            // Insert the button into the results content area, not the resultsPane container
            // Find a better container within resultsPane (like after recommendations)
            const recommendationsDiv = document.getElementById('recommendations');
            recommendationsDiv.appendChild(exploreButton);
        }, 500); // Match quizContainer opacity transition duration
    }

    /**
     * Transitions from the full-screen results page to the full-screen scrollable visualization page.
     * Minimizes the results pane to a corner and makes the visualization area full screen.
     */
    function transitionToVizPage() {
        const resultsPane = document.getElementById('resultsPane');
        const visualizationArea = document.getElementById('visualizationArea');
        const toggleButton = resultsPane.querySelector('.toggle-button');

        // Clear any automatic transition timeout if a manual toggle occurs
        clearTimeout(autoTransitionTimeout);

        // Remove full-screen-results class
        resultsPane.classList.remove('full-screen-results');

        // Minimize results pane to the corner
        resultsPane.classList.add('minimized');
        toggleButton.style.display = 'block'; // Show toggle button in minimized state
        toggleButton.textContent = 'Expand Results'; // Set initial text

        // Make visualizationArea visible and allow it to grow to full screen
        visualizationArea.style.display = 'flex'; // Ensure it's active in the flex container

        // Re-draw ALL D3 visualizations to ensure they fit the new full-screen visualization area
        renderAllVisualizations();
    }

    /**
     * Renders all D3 visualizations. This is called when the visualization area
     * changes size (e.g., when results pane is toggled or on initial transition).
     */

     async function renderAllVisualizations() {
  // Retrieve user data directly here, ensuring it's fresh after quiz submission
  const userAge = parseInt(document.getElementById('age').value);

  let userGender = document.getElementById('gender').value; // e.g., "male", "female", "other"
  // Normalize gender to match the format used in your D3 visualization ("Male", "Female")
  userGender = userGender?.trim().toLowerCase();
  if (userGender === "m" || userGender === "male") userGender = "Male";
  else if (userGender === "f" || userGender === "female") userGender = "Female";
  else userGender = null; // Handle 'other' or unrecognized genders

  // Access the calculated score. Assuming 'finalPredictedScore' is a global variable
  // that is set by calculateResults() before renderAllVisualizations() is called.
  const miniBESTestScore = finalPredictedScore; // This should now correctly hold the calculated score

  // Log values to console for debugging!
  console.log("Rendering Visualizations with:");
  console.log("User Age:", userAge);
  console.log("User Gender:", userGender);
  console.log("Mini-BESTest Score:", miniBESTestScore);

  // Call the personalized visualization function with await
  if (userGender !== null && !isNaN(userAge) && !isNaN(miniBESTestScore)) {
    await createD3Visualization1(userAge, userGender, miniBESTestScore);
  } else {
    console.warn("User data incomplete for personalized visualization. Displaying general trends.");
    // Fallback: call the visualization without user-specific data if needed
    await createD3Visualization1(null, null, null); // This will draw trends but no user dot
  }
  const userHeight = parseFloat(document.getElementById('height').value);
  // Call your other visualization functions here (add await if they are async)
  await createD3Visualization4(userHeight,miniBESTestScore);
  await createD3Visualization2(); // Assuming this is async if it loads CSV
  await createD3Visualization3(); // Assuming this is async if it loads CSV
  await createD3Visualization5();

}


    
    /**
     * Creates and displays a comparison chart of the user's score against a fictional population distribution.
     * Uses D3.js for visualization.
     * @param {number} userScore - The user's predicted Mini-BESTest score.
     */


    function createComparisonChart(userScore) {
        const chartContainer = d3.select('#comparisonChart');
        chartContainer.selectAll("*").remove(); // Clear previous chart to prevent duplication

        const svg = chartContainer
            .append('svg')
            .attr('viewBox', `0 0 600 350`); // Use viewBox for responsiveness

        const width = 600;
        const height = 350;
        const margin = {top: 40, right: 30, bottom: 60, left: 60};

        // Sample data representing study population distribution (fictional)
        const data = [
            {range: '0-7', count: 5, color: '#ff6b6b'},
            {range: '8-15', count: 15, color: '#feca57'},
            {range: '16-23', count: 45, color: '#48dbfb'},
            {range: '24-28', count: 35, color: '#1dd1a1'}
        ];

        const x = d3.scaleBand()
            .domain(data.map(d => d.range))
            .range([margin.left, width - margin.right])
            .padding(0.1);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.count) * 1.1]) // Add some padding to the top
            .range([height - margin.bottom, margin.top]);

        // Draw bars
        svg.selectAll('rect')
            .data(data)
            .enter()
            .append('rect')
            .attr('x', d => x(d.range))
            .attr('y', d => y(d.count))
            .attr('width', x.bandwidth())
            .attr('height', d => height - margin.bottom - y(d.count))
            .attr('fill', d => d.color)
            .attr('opacity', 0.8);

        // Add user score indicator
        const userRange = userScore <= 7 ? '0-7' :
                         userScore <= 15 ? '8-15' :
                         userScore <= 23 ? '16-23' : '24-28';

        const userXPos = x(userRange) + x.bandwidth() / 2;

        svg.append('line')
            .attr('x1', userXPos)
            .attr('x2', userXPos)
            .attr('y1', y(d3.max(data, d => d.count) * 1.05)) // Start above highest bar
            .attr('y2', height - margin.bottom)
            .attr('stroke', '#2c3e50')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5');

        svg.append('text')
            .attr('x', userXPos)
            .attr('y', y(d3.max(data, d => d.count) * 1.05) - 10)
            .attr('text-anchor', 'middle')
            .attr('font-weight', 'bold')
            .attr('fill', '#2c3e50')
            .text('Your Score');

        // Add axes
        svg.append('g')
            .attr('transform', `translate(0,${height - margin.bottom})`)
            .call(d3.axisBottom(x))
            .selectAll("text")
            .style("font-size", "12px");

        svg.append('g')
            .attr('transform', `translate(${margin.left},0)`)
            .call(d3.axisLeft(y).tickFormat(d => `${d}%`)) // Assuming percentages
            .selectAll("text")
            .style("font-size", "12px");

        // Add labels
        svg.append('text')
            .attr('x', width / 2)
            .attr('y', height - 10)
            .attr('text-anchor', 'middle')
            .style("font-size", "14px")
            .style("font-weight", "bold")
            .text('Mini-BESTest Score Range');

        svg.append('text')
            .attr('transform', 'rotate(-90)')
            .attr('x', -height / 2)
            .attr('y', 20)
            .attr('text-anchor', 'middle')
            .style("font-size", "14px")
            .style("font-weight", "bold")
            .text('Number of Participants (%)');

        // Title
        svg.append("text")
            .attr("x", (width / 2))
            .attr("y", margin.top / 2 + 5)
            .attr("text-anchor", "middle")
            .style("font-size", "18px")
            .style("font-weight", "bold")
            .text("Your Score vs. Population Distribution");
    }


// Ensure you are using this exact createD3Visualization1 function
async function createD3Visualization1(userAge, userGender, userScore) {
  const svg = d3.select("#viz1 svg");
  svg.selectAll("*").remove(); // Clear previous chart

  const width = parseInt(svg.style("width")) || 600;
  const height = parseInt(svg.style("height")) || 400;
  const margin = { top: 30, right: 30, bottom: 50, left: 60 };

  const innerWidth = width - margin.left - margin.right;
  const innerHeight = height - margin.top - margin.bottom;

  const chartGroup = svg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

  const data = await d3.csv("BDSinfo.csv", d => {
    let gender = d.Gender?.trim().toLowerCase();
    if (gender === "m" || gender === "male") gender = "Male";
    else if (gender === "f" || gender === "female") gender = "Female";
    else gender = null;
    return { Age: +d.Age, Best_T: +d.Best_T, Gender: gender };
  });

  const filteredData = data.filter(d =>
    !isNaN(d.Age) &&
    !isNaN(d.Best_T) &&
    (d.Gender === "Male" || d.Gender === "Female")
  );

  const x = d3.scaleLinear()
    .domain(d3.extent(filteredData, d => d.Age)).nice()
    .range([0, innerWidth]);

  const y = d3.scaleLinear()
    .domain([0, 28])
    .range([innerHeight, 0]);

  const color = d3.scaleOrdinal()
    .domain(["Male", "Female"])
    .range(["#000080", "#C11C84"]);

  function linearRegression(xData, yData) {
    const n = xData.length;
    const sumX = d3.sum(xData);
    const sumY = d3.sum(yData);
    const sumXY = d3.sum(xData.map((x, i) => x * yData[i]));
    const sumXX = d3.sum(xData.map(x => x * x));
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    return { slope, intercept };
  }

  const maleData = filteredData.filter(d => d.Gender === "Male");
  const femaleData = filteredData.filter(d => d.Gender === "Female");

  const maleRegression = linearRegression(maleData.map(d => d.Age), maleData.map(d => d.Best_T));
  const femaleRegression = linearRegression(femaleData.map(d => d.Age), femaleData.map(d => d.Best_T));

  const minAge = d3.min(filteredData, d => d.Age);
  const maxAge = d3.max(filteredData, d => d.Age);

  const maleRegressionLineData = [
    { x: minAge, y: maleRegression.slope * minAge + maleRegression.intercept },
    { x: maxAge, y: maleRegression.slope * maxAge + maleRegression.intercept }
  ];

  const femaleRegressionLineData = [
    { x: minAge, y: femaleRegression.slope * minAge + femaleRegression.intercept },
    { x: maxAge, y: femaleRegression.slope * maxAge + femaleRegression.intercept }
  ];

  const line = d3.line()
    .x(d => x(d.x))
    .y(d => y(d.y));

  chartGroup.append("path")
    .datum(maleRegressionLineData)
    .attr("class", "regression-line male-trend")
    .attr("d", line)
    .attr("stroke", color("Male"))
    .attr("stroke-width", 2)
    .attr("fill", "none")
    .attr("stroke-dasharray", "4,2");

  chartGroup.append("path")
    .datum(femaleRegressionLineData)
    .attr("class", "regression-line female-trend")
    .attr("d", line)
    .attr("stroke", color("Female"))
    .attr("stroke-width", 2)
    .attr("fill", "none")
    .attr("stroke-dasharray", "4,2");

  chartGroup.append("g")
    .attr("transform", `translate(0,${innerHeight})`)
    .call(d3.axisBottom(x))
    .append("text")
    .attr("x", innerWidth / 2)
    .attr("y", 40)
    .attr("fill", "#000")
    .attr("text-anchor", "middle")
    .text("Age");

  chartGroup.append("g")
    .call(d3.axisLeft(y))
    .append("text")
    .attr("x", -innerHeight / 2)
    .attr("y", -45)
    .attr("transform", "rotate(-90)")
    .attr("fill", "#000")
    .attr("text-anchor", "middle")
    .text("Balance Score (Best_T)");

  chartGroup.selectAll(".data-point")
    .data(filteredData)
    .enter()
    .append("circle")
    .attr("class", "data-point")
    .attr("cx", d => x(d.Age))
    .attr("cy", d => y(d.Best_T))
    .attr("r", 3)
    .attr("fill", d => color(d.Gender))
    .attr("opacity", 0.4);

  // Add the user's personalized point (initially at their current age)
  const userPointColor = (userGender === "Male") ? "#0000FF" : (userGender === "Female") ? "#FF00FF" : "purple";
  const userDot = chartGroup.append("circle")
    .attr("cx", x(userAge))
    .attr("cy", y(userScore))
    .attr("r", 8)
    .attr("fill", userPointColor)
    .attr("stroke", "white")
    .attr("stroke-width", 2)
    .attr("class", "user-point");

  const userLabel = chartGroup.append("text")
    .attr("x", x(userAge) + 12)
    .attr("y", y(userScore) + 4)
    .text("You")
    .attr("fill", userPointColor)
    .style("font-weight", "bold")
    .style("font-size", "14px")
    .attr("class", "user-label");

  userDot.append("title")
    .text(`Your Current Score: Age ${userAge}, Score ${userScore}`);

  // Legend
  const legendData = [
      { label: "Male Trend", color: color("Male"), dash: true },
      { label: "Female Trend", color: color("Female"), dash: true },
      { label: "All Data Points", color: "#666", dash: false, radius: 3 },
      { label: "Your Score", color: userPointColor, dash: false, radius: 8 }
  ];

  const legend = svg.selectAll(".legend")
    .data(legendData)
    .enter()
    .append("g")
    .attr("class", "legend")
    .attr("transform", (d, i) => `translate(${width - margin.right - 120},${margin.top + i * 20})`);

  legend.each(function(d) {
      const g = d3.select(this);
      if (d.dash) {
          g.append("line")
              .attr("x1", 0)
              .attr("x2", 15)
              .attr("y1", 5)
              .attr("y2", 5)
              .attr("stroke", d.color)
              .attr("stroke-width", 2)
              .attr("stroke-dasharray", "4,2");
      } else {
          g.append("circle")
              .attr("cx", 7.5)
              .attr("cy", 5)
              .attr("r", d.radius)
              .attr("fill", d.color);
      }
      g.append("text")
          .attr("x", 20)
          .attr("y", 9)
          .text(d.label)
          .attr("font-size", "12px")
          .attr("alignment-baseline", "middle");
  });

  // --- Scroll Animation Logic ---
  
  // Get the appropriate regression line based on user's gender
  let userRegression;
  if (userGender === "Male") {
    userRegression = maleRegression;
  } else if (userGender === "Female") {
    userRegression = femaleRegression;
  } else {
    // For "Other" or any non-binary gender, use average of male and female slopes
    userRegression = {
      slope: (maleRegression.slope + femaleRegression.slope) / 2,
      intercept: (maleRegression.intercept + femaleRegression.intercept) / 2
    };
  }
  
  // Calculate projection line data from user's current position
  const projectionEndAge = maxAge; // Project to the maximum age in the dataset
  const projectionEndScore = userRegression.slope * projectionEndAge + userRegression.intercept;
  
  // Create projection line data
  const projectionLineData = [
    { x: userAge, y: userScore },
    { x: projectionEndAge, y: projectionEndScore }
  ];
  
  // Create the projection line (initially hidden)
  const projectionLine = chartGroup.append("path")
    .datum(projectionLineData)
    .attr("class", "user-projection-line")
    .attr("d", line)
    .attr("stroke", userPointColor)
    .attr("stroke-width", 3)
    .attr("fill", "none")
    .attr("stroke-dasharray", "8,4")
    .attr("opacity", 0)
    .style("filter", "drop-shadow(0 0 3px rgba(0,0,0,0.3))");

  // Add end point marker for projection
  const projectionEndPoint = chartGroup.append("circle")
    .attr("cx", x(projectionEndAge))
    .attr("cy", y(projectionEndScore))
    .attr("r", 6)
    .attr("fill", userPointColor)
    .attr("stroke", "white")
    .attr("stroke-width", 2)
    .attr("opacity", 0)
    .attr("class", "projection-end-point");

  // Add label for projection end point
  const projectionLabel = chartGroup.append("text")
    .attr("x", x(projectionEndAge) + 12)
    .attr("y", y(projectionEndScore) + 4)
    .text(`Age ${Math.round(projectionEndAge)}`)
    .attr("fill", userPointColor)
    .style("font-weight", "bold")
    .style("font-size", "12px")
    .attr("opacity", 0)
    .attr("class", "projection-label");

  // Scroll event handler
  let animationTriggered = false;
  
  function triggerAnimation() {
    if (animationTriggered) return;
    animationTriggered = true;
    
    // Animate the projection line appearing
    projectionLine
      .transition()
      .duration(1500)
      .ease(d3.easeQuadOut)
      .attr("opacity", 0.8)
      .attrTween("stroke-dasharray", function() {
        const length = this.getTotalLength();
        return d3.interpolateString(`0,${length}`, `${length},${length}`);
      });
    
    // Animate the end point appearing
    projectionEndPoint
      .transition()
      .delay(1200)
      .duration(500)
      .ease(d3.easeBackOut)
      .attr("opacity", 1)
      .attr("r", 6);
    
    // Animate the label appearing
    projectionLabel
      .transition()
      .delay(1400)
      .duration(300)
      .attr("opacity", 1);
    
    // Add a subtle pulse effect to the user dot
    userDot
      .transition()
      .delay(800)
      .duration(200)
      .attr("r", 12)
      .transition()
      .duration(200)
      .attr("r", 8);
  }
  
  function handleScroll() {
    if (animationTriggered) return;
    
    const vizElement = document.querySelector("#viz1");
    if (!vizElement) return;
    
    const vizRect = vizElement.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    
    // Trigger animation when even a small part of viz comes into view (much earlier trigger)
    if (vizRect.bottom > windowHeight * 0.1) { // Trigger when bottom of viz is 10% into viewport
      triggerAnimation();
    }
  }
  
  // Check if visualization is already in viewport on load
  function checkInitialVisibility() {
    const vizElement = document.querySelector("#viz1");
    if (!vizElement) return;
    
    // For visualizations high on the page, trigger animation shortly after load
    setTimeout(() => {
      triggerAnimation();
    }, 800); // Reduced delay for earlier trigger
  }
  
  // Add scroll listener
  window.addEventListener('scroll', handleScroll);
  
  // Check initial visibility after a brief delay to ensure DOM is ready
  setTimeout(checkInitialVisibility, 500);
  
  // Clean up function to remove scroll listener (call this when component unmounts)
  window.removeScrollListener = function() {
    window.removeEventListener('scroll', handleScroll);
  };

  // Display regression equations (optional, for console logging/debugging)
  console.log(`Male Trend: y = ${maleRegression.slope.toFixed(4)}x + ${maleRegression.intercept.toFixed(4)}`);
  console.log(`Female Trend: y = ${femaleRegression.slope.toFixed(4)}x + ${femaleRegression.intercept.toFixed(4)}`);
}
   
async function createD3Visualization2() {
  const svg = d3.select("#viz3 svg");
  svg.selectAll("*").remove();

  const width = parseInt(svg.style("width"));
  const height = parseInt(svg.style("height"));
  const margin = { top: 30, right: 30, bottom: 60, left: 60 };

  const data = await d3.csv("BDSinfo.csv", d => ({
    Age: +d.Age,
    IPAQ_1b: +d.IPAQ_1b,
    Best_T: +d.Best_T
  }));

  // Filter: people under 52
  const young = data.filter(d => d.Age < 52 && !isNaN(d.IPAQ_1b) && !isNaN(d.Best_T));

  // Group by IPAQ_1b, compute mean Best_T
  const grouped = Array.from(
    d3.rollup(
      young,
      v => d3.mean(v, d => d.Best_T),
      d => d.IPAQ_1b
    ),
    ([IPAQ_1b, avgBalance]) => ({ IPAQ_1b: +IPAQ_1b, avgBalance })
  ).sort((a, b) => a.IPAQ_1b - b.IPAQ_1b); // sort by IPAQ minutes

  const x = d3.scaleLinear()
    .domain(d3.extent(grouped, d => d.IPAQ_1b))
    .range([margin.left, width - margin.right]);

  const y = d3.scaleLinear()
    .domain([18, 28])
    .range([height - margin.bottom, margin.top]);

  // X Axis
  svg.append("g")
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x).ticks(6))
    .append("text")
    .attr("x", width - margin.right)
    .attr("y", -10)
    .attr("text-anchor", "end")
    .attr("fill", "black")
    .text("Moderate Activity (minutes)");

  // Y Axis
  svg.append("g")
    .attr("transform", `translate(${margin.left},0)`)
    .call(d3.axisLeft(y))
    .append("text")
    .attr("x", 0)
    .attr("y", margin.top)
    .attr("text-anchor", "start")
    .attr("fill", "black")
    .text("Avg Balance Score (Best_T)");

  // Line generator
  const line = d3.line()
    .x(d => x(d.IPAQ_1b))
    .y(d => y(d.avgBalance));

  // Draw line
  svg.append("path")
    .datum(grouped)
    .attr("fill", "none")
    .attr("stroke", "#9F2B68")
    .attr("stroke-width", 2.5)
    .attr("d", line);
  
    const userIPAQ = assessmentData?.ipaq1b;

if (!isNaN(userIPAQ)) {
  // Interpolate user's y-position from line
  const xVals = grouped.map(d => d.IPAQ_1b);
  const yVals = grouped.map(d => d.avgBalance);

  // Find the two closest IPAQ points
  let i = d3.bisector(d => d.IPAQ_1b).left(grouped, userIPAQ);
  if (i > 0 && i < grouped.length) {
    const left = grouped[i - 1];
    const right = grouped[i];
    const slope = (right.avgBalance - left.avgBalance) / (right.IPAQ_1b - left.IPAQ_1b);
    var estimatedY = left.avgBalance + slope * (userIPAQ - left.IPAQ_1b);
  } else {
    // If out of bounds, just clamp to nearest
    var estimatedY = grouped[i >= grouped.length ? grouped.length - 1 : 0].avgBalance;
  }

  // Draw user dot
  svg.append("circle")
    .attr("cx", x(userIPAQ))
    .attr("cy", y(estimatedY))
    .attr("r", 6)
    .attr("fill", "#C3B1E1")
    .attr("stroke", "#333")
    .attr("stroke-width", 1.2);

  // Add "You" label next to the dot
  svg.append("text")
    .attr("x", x(userIPAQ) + 8)
    .attr("y", y(estimatedY) - 8)
    .attr("fill", "#C3B1E1")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("text-anchor", "start")
    .text("You");
}

}



async function createD3Visualization3() {
  const svg = d3.select("#viz4 svg");
  svg.selectAll("*").remove();
  d3.select("#footwearSelect").selectAll("option:not(:first-child)").remove(); // reset dropdown

  const width = parseInt(svg.style("width"));
  const height = parseInt(svg.style("height"));
  const margin = { top: 30, right: 30, bottom: 80, left: 60 };

  const excludedCategories = new Set([
    'Walking shoes, Flip-Flops', 'Walking shoes, casual shoes', 'Walking shoes, Flip-Flops, Casual shoes',
    'Walking shoes, Boots', 'Casual shoes, Dress shoes', 'Casual shoes, Flip-Flops',
    'Walking shoes, Sandal', 'Sandal, Casual shoes', 'Casual shoes, Sandal'
  ].map(d => d.toLowerCase().trim()));

  const data = await d3.csv("BDSinfo.csv", d => {
    const trimmedFootwear = d.Footwear?.trim();
    return {
      Footwear: trimmedFootwear,
      normalizedFootwear: trimmedFootwear?.toLowerCase(),
      Best_T: +d.Best_T
    };
  });

  const filtered = data.filter(d =>
    d.normalizedFootwear &&
    !excludedCategories.has(d.normalizedFootwear) &&
    !isNaN(d.Best_T)
  );

  const grouped = d3.rollups(
    filtered,
    v => d3.mean(v, d => d.Best_T),
    d => d.Footwear
  ).map(([footwear, avgBalance]) => ({
    Footwear: footwear,
    normalizedFootwear: footwear.toLowerCase().trim(),
    avgBalance
  }));

  grouped.sort((a, b) => b.avgBalance - a.avgBalance);

  const x = d3.scaleBand()
    .domain(grouped.map(d => d.Footwear))
    .range([margin.left, width - margin.right])
    .padding(0.2);

  const y = d3.scaleLinear()
    .domain([0, 28])
    .range([height - margin.bottom, margin.top]);

    svg.append("g")
      .attr("transform", `translate(0,${height - margin.bottom})`)
      .call(d3.axisBottom(x))
      .selectAll("text")
      .each(function (d) {
        const text = d3.select(this);
        const words = d.split(" "); 
        text.text(null);
    
        // Wrap words into 2-word lines
        const lineLength = 2;
        for (let i = 0; i < words.length; i += lineLength) {
          text.append("tspan")
            .text(words.slice(i, i + lineLength).join(" "))
            .attr("x", 0)
            .attr("dy", i === 0 ? 0 : "1em");
        }
    })
  .attr("text-anchor", "end")
  .attr("transform", "rotate(-35)")
  .attr("dx", "-0.8em")
  .attr("dy", "0.15em");



  svg.append("g")
    .attr("transform", `translate(${margin.left},0)`)
    .call(d3.axisLeft(y));

  // Draw bars with class
  svg.selectAll("rect")
    .data(grouped)
    .enter()
    .append("rect")
    .attr("class", d => "bar bar-" + d.normalizedFootwear.replace(/[^a-z0-9]/g, "-"))
    .attr("x", d => x(d.Footwear))
    .attr("y", d => y(d.avgBalance))
    .attr("width", x.bandwidth())
    .attr("height", d => height - margin.bottom - y(d.avgBalance))
    .attr("fill", "#93C572");

  svg.selectAll(".label")
    .data(grouped)
    .enter()
    .append("text")
    .attr("x", d => x(d.Footwear) + x.bandwidth() / 2)
    .attr("y", d => y(d.avgBalance) - 5)
    .attr("text-anchor", "middle")
    .attr("font-size", "11px")
    .attr("fill", "#333")
    .text(d => d.avgBalance.toFixed(1));

  // Populate dropdown
  const dropdown = d3.select("#footwearSelect");
  grouped.forEach(d => {
    dropdown.append("option")
      .attr("value", d.normalizedFootwear)
      .text(d.Footwear);
  });

  // Highlight selected bar
  dropdown.on("change", function () {
    const selected = this.value;

    svg.selectAll("rect")
      .attr("fill", d => d.normalizedFootwear === selected ? "#B4C424" : "#93C572");
  });
}


async function createD3Visualization4(userHeight, miniBESTestScore) {
  const svg = d3.select("#viz2 svg");
  if (svg.empty()) {
    console.error("Error: SVG element with ID 'viz4' or its nested SVG not found.");
    return;
  }

  svg.selectAll("*").remove();

  const width = parseInt(svg.style("width"));
  const height = parseInt(svg.style("height"));
  const margin = { top: 60, right: 30, bottom: 100, left: 80 };

  const data = await d3.csv("BDSinfo.csv", d => ({
    Height: +d.Height?.trim() * 0.393701,
    Weight: +d.Weight?.trim(),
    Best_T: +d.Best_T?.trim()
  }));

  const filtered = data.filter(d =>
    !isNaN(d.Height) &&
    !isNaN(d.Weight) &&
    !isNaN(d.Best_T)
  );

  if (filtered.length === 0) {
    svg.append("text")
      .attr("x", width / 2)
      .attr("y", height / 2)
      .attr("text-anchor", "middle")
      .style("font-size", "16px")
      .text("No valid Height and Mini-BESTest data found.");
    return;
  }

  const x = d3.scaleLinear()
    .domain(d3.extent(filtered, d => d.Height)).nice()
    .range([margin.left, width - margin.right]);

  const y = d3.scaleLinear()
    .domain(d3.extent(filtered, d => d.Best_T)).nice()
    .range([height - margin.bottom, margin.top]);

  svg.append("g")
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x));

  svg.append("g")
    .attr("transform", `translate(${margin.left},0)`)
    .call(d3.axisLeft(y));

  svg.append("text")
    .attr("x", width / 2)
    .attr("y", height - 50)
    .attr("text-anchor", "middle")
    .style("font-size", "14px")
    .text("Height (inches)");

  svg.append("text")
    .attr("transform", "rotate(-90)")
    .attr("x", -height / 2)
    .attr("y", 25)
    .attr("text-anchor", "middle")
    .style("font-size", "14px")
    .text("Mini-BESTest Score");

  // Tooltip
  const tooltip = d3.select("#viz2").append("div")
    .attr("class", "tooltip")
    .style("position", "absolute")
    .style("visibility", "hidden")
    .style("background", "#fff")
    .style("border", "1px solid #ccc")
    .style("padding", "10px")
    .style("border-radius", "6px")
    .style("font-size", "13px")
    .style("box-shadow", "0 2px 5px rgba(0,0,0,0.3)");

  svg.on("click", event => {
    if (event.target.tagName !== 'circle' && !event.target.closest("#viz4 div")) {
      tooltip.style("visibility", "hidden");
    }
  });

  svg.selectAll("circle.data-point")
    .data(filtered)
    .enter()
    .append("circle")
    .attr("class", "data-point")
    .attr("cx", d => x(d.Height))
    .attr("cy", d => y(d.Best_T))
    .attr("r", 5)
    .attr("fill", "#007acc")
    .attr("opacity", 0.8)
    .style("cursor", "pointer")
    .on("click", (event, d) => {
      if (!d || isNaN(d.Height) || isNaN(d.Best_T)) {
        tooltip.style("visibility", "hidden");
        return;
      }

      tooltip
        .style("visibility", "visible")
        .style("top", `${event.pageY - 60}px`)
        .style("left", `${event.pageX + 10}px`)
        .html(`
          <div>
            <strong>Height:</strong> ${d.Height.toFixed(1)} in<br/>
            <strong>Mini-BESTest Score:</strong> ${d.Best_T.toFixed(1)}
          </div>
        `);
    });

  // Regression Line
  const n = filtered.length;
  const sumX = d3.sum(filtered, d => d.Height);
  const sumY = d3.sum(filtered, d => d.Best_T);
  const sumXY = d3.sum(filtered, d => d.Height * d.Best_T);
  const sumX2 = d3.sum(filtered, d => d.Height * d.Height);

  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;

  const predictions = filtered.map(d => {
    const yPred = slope * d.Height + intercept;
    return { ...d, predicted: yPred, residual: d.Best_T - yPred };
  });

  const se = Math.sqrt(d3.mean(predictions.map(d => d.residual ** 2)));
  const xRange = d3.range(x.domain()[0], x.domain()[1], 0.5);
  const meanX = sumX / n;

  const confidenceData = xRange.map(xVal => {
    const yVal = slope * xVal + intercept;
    const seY = se * Math.sqrt(1 / n + (xVal - meanX) ** 2 / (sumX2 - (sumX ** 2) / n));
    const margin = 1.96 * seY;
    return {
      x: xVal,
      y: yVal,
      yLow: yVal - margin,
      yHigh: yVal + margin
    };
  });

  svg.append("path")
    .datum(confidenceData)
    .attr("fill", "#fdd")
    .attr("stroke", "none")
    .attr("opacity", 0.4)
    .attr("d", d3.area()
      .x(d => x(d.x))
      .y0(d => y(d.yLow))
      .y1(d => y(d.yHigh))
    );

  svg.append("line")
    .attr("x1", x(xRange[0]))
    .attr("y1", y(slope * xRange[0] + intercept))
    .attr("x2", x(xRange[xRange.length - 1]))
    .attr("y2", y(slope * xRange[xRange.length - 1] + intercept))
    .attr("stroke", "#e45756")
    .attr("stroke-width", 2)
    .attr("stroke-dasharray", "5,5");

  // "You" marker
  if (!isNaN(userHeight) && !isNaN(miniBESTestScore)) {
    const heightInInches = userHeight;
    svg.append("circle")
      .attr("cx", x(heightInInches))
      .attr("cy", y(miniBESTestScore))
      .attr("r", 6)
      .attr("fill", "#e45756")
      .attr("stroke", "#000")
      .attr("stroke-width", 1.5);

    svg.append("text")
      .attr("x", x(heightInInches) + 8)
      .attr("y", y(miniBESTestScore) - 8)
      .text("You")
      .style("font-size", "13px")
      .style("font-weight", "bold")
      .style("fill", "#e45756");
  }

 
  // Legend
  const legend = svg.append("g")
    .attr("transform", `translate(${width - 180}, ${margin.top})`);

  legend.append("circle")
    .attr("cx", 0)
    .attr("cy", 0)
    .attr("r", 5)
    .attr("fill", "#007acc");

  legend.append("text")
    .attr("x", 12)
    .attr("y", 5)
    .text("Data point")
    .style("font-size", "12px");

  legend.append("line")
    .attr("x1", 0)
    .attr("y1", 20)
    .attr("x2", 20)
    .attr("y2", 20)
    .attr("stroke", "#e45756")
    .attr("stroke-dasharray", "5,5")
    .attr("stroke-width", 2);

  legend.append("text")
    .attr("x", 25)
    .attr("y", 24)
    .text("Regression line")
    .style("font-size", "12px");

  legend.append("rect")
    .attr("x", 0)
    .attr("y", 35)
    .attr("width", 20)
    .attr("height", 10)
    .attr("fill", "#fdd")
    .attr("opacity", 0.4);

  legend.append("text")
    .attr("x", 25)
    .attr("y", 44)
    .text("95% Confidence band")
    .style("font-size", "12px");

  legend.append("circle")
    .attr("cx", 5)
    .attr("cy", 60)
    .attr("r", 6)
    .attr("fill", "#e45756")
    .attr("stroke", "#000");

  legend.append("text")
    .attr("x", 16)
    .attr("y", 64)
    .text('"You"')
    .style("font-size", "12px")
    .style("font-weight", "bold");
}

    /**
     * Downloads the complete assessment results as a JSON file.
     */
    function downloadResults() {
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(assessmentData, null, 2));
        const dlAnchor = document.createElement('a');
        dlAnchor.setAttribute("href", dataStr);
        dlAnchor.setAttribute("download", "balance_assessment_full_results.json");
        dlAnchor.click();
    }

    /**
     * Downloads a summary of the predicted score and recommendations as a plain text file.
     */
    function downloadScore() {
        if (finalPredictedScore === null) {
            alert("Score not yet calculated. Please complete the quiz.");
            return;
        }

        const scoreText = `Your Predicted Mini-BESTest Score: ${finalPredictedScore.toFixed(1)}\n` +
                          `Interpretation: ${document.getElementById('scoreInterpretation').textContent}\n` +
                          `Recommendations: ${document.getElementById('recommendations').textContent.replace('Recommendations:', '').trim()}`;

        const dataStr = "data:text/plain;charset=utf-8," + encodeURIComponent(scoreText);
        const dlAnchor = document.createElement('a');
        dlAnchor.setAttribute("href", dataStr);
        dlAnchor.setAttribute("download", "balance_score_summary.txt");
        dlAnchor.click();
    }

    /**
     * Toggles the results pane between expanded (sidebar) and minimized (corner) states.
     * This function is primarily used on the visualization page.
     */
    function toggleResultsPane() {
        const resultsPane = document.getElementById('resultsPane');
        const visualizationArea = document.getElementById('visualizationArea');
        const toggleButton = resultsPane.querySelector('.toggle-button');

        // Clear any automatic transition timeout if a manual toggle occurs
        clearTimeout(autoTransitionTimeout);

        if (resultsPane.classList.contains('minimized')) {
            // Expand the pane (split-screen mode)
            resultsPane.classList.remove('minimized');
            toggleButton.textContent = 'Minimize Results';

            // Restore resultsPane to sidebar flex properties
            resultsPane.style.position = 'relative'; // Important for flexbox layout
            resultsPane.style.width = 'auto'; // Let flex-basis manage width
            resultsPane.style.height = '100vh'; // Fill height
            resultsPane.style.bottom = 'auto'; // Remove fixed positioning
            resultsPane.style.right = 'auto'; // Remove fixed positioning
            resultsPane.style.flex = '0 0 350px'; // Set to sidebar width
            resultsPane.style.padding = '20px'; // Restore original padding

            // Make sure visualization area is visible when expanded
            visualizationArea.style.display = 'flex'; // Ensure it's flex

            // Re-draw ALL D3 visualizations to fit the new (shrunk) visualization area size
            renderAllVisualizations();

        } else {
            // Minimize the pane (full-screen visualization mode)
            resultsPane.classList.add('minimized');
            toggleButton.textContent = 'Expand Results';

            // When resultsPane gets 'position: fixed', it's taken out of the flex flow.
            // visualizationArea, which has 'flex-grow: 1', will then naturally expand
            // to fill the entire remaining space of 'mainContent', thus becoming full screen.
            // No explicit style changes needed on visualizationArea for 'full-screen'.

            // Make sure visualization area is visible when minimized
            visualizationArea.style.display = 'flex'; // Ensure it's flex

            // Re-draw ALL D3 visualizations to fit the new (expanded) visualization area size
            renderAllVisualizations();
        }
    }

    /**
     * Resets the entire assessment, clearing all data and returning to the welcome screen.
     */
    function resetAssessment() {
        // Clear any pending timeouts
        clearTimeout(autoTransitionTimeout);

        currentStep = 0; // Reset to welcome screen
        assessmentData = {};
        tmtCompleted = false;
        tmtCurrentNumber = 1;
        tmtStartTime = null;
        finalPredictedScore = null; // Clear stored score

        // Reset all steps visibility
        document.querySelectorAll('.step').forEach(step => step.classList.remove('active'));
        document.getElementById('step0').classList.add('active'); // Show welcome screen

        // Clear all input fields and selections
        document.querySelectorAll('input').forEach(input => {
            if (input.type === 'number' || input.type === 'text') {
                input.value = '';
            }
        });
        document.querySelectorAll('select').forEach(select => select.selectedIndex = 0);
        document.querySelectorAll('.likert-option').forEach(opt => opt.classList.remove('selected'));

        // Reset TMT display
        initializeTMT(); // This will clear and re-render the grid

        // Clear results section content in resultsPane
        document.getElementById('predictedScore').textContent = '';
        document.getElementById('scoreInterpretation').innerHTML = '';
        document.getElementById('recommendations').innerHTML = '';
        d3.select('#comparisonChart').selectAll("*").remove(); // Clear D3 comparison chart

        // Also clear visualizations in the visualization area
        d3.select('#viz1 svg').selectAll("*").remove();
        d3.select('#viz2 svg').selectAll("*").remove();
        d3.select('#viz3 svg').selectAll("*").remove();
        d3.select('#viz4 svg').selectAll("*").remove();
        d3.select('#viz5 svg').selectAll("*").remove();


        // Reset resultsPane and visualizationArea styles to initial (hidden/default) state
        const resultsPane = document.getElementById('resultsPane');
        const visualizationArea = document.getElementById('visualizationArea');
        const toggleButton = resultsPane.querySelector('.toggle-button');

        resultsPane.classList.remove('full-screen-results', 'minimized');
        resultsPane.style.display = 'flex'; // Default display for resultsPane
        resultsPane.style.flex = '0 0 350px'; // Default flex
        resultsPane.style.position = 'relative'; // Default position
        resultsPane.style.width = 'auto'; // Default width
        resultsPane.style.height = '100vh'; // Default height
        resultsPane.style.bottom = 'auto'; // Reset fixed position properties
        resultsPane.style.right = 'auto'; // Reset fixed position properties
        resultsPane.style.padding = '20px'; // Default padding
        toggleButton.style.display = 'block'; // Ensure toggle button is visible (will be hidden by .full-screen-results later)

        // *** CRITICAL FIX HERE: Ensure visualizationArea is hidden before mainContent is hidden ***
        visualizationArea.style.display = 'none'; // Hide visualization area explicitly

        // Hide main content split view with a fade-out and disable interactions
        document.getElementById('mainContent').style.opacity = 0;
        document.getElementById('mainContent').style.pointerEvents = 'none';
        setTimeout(() => {
            document.getElementById('mainContent').style.display = 'none'; // Hide mainContent after fade-out
        }, 500);

        // Show quiz container with a fade-in
        document.getElementById('quizContainer').style.display = 'block';
        document.getElementById('quizContainer').style.opacity = 1;

        // Reset the scroll position of the quiz container
        document.getElementById('quizContainer').scrollTop = 0;

        updateProgress();
    }
    async function createD3Visualization5() {
  const svg = d3.select("#viz5 svg");
  svg.selectAll("*").remove();

  const width = parseInt(svg.style("width")) || 600;
  const height = parseInt(svg.style("height")) || 350;
  const margin = { top: 60, right: 40, bottom: 60, left: 60 };

  // Load and preprocess data
  const data = await d3.csv("BDSinfo.csv", d => ({
    Age: +d.Age,
    Best_T: +d.Best_T,
    IPAQ_1b: +d.IPAQ_1b,
    Footwear: d.Footwear?.toLowerCase().trim()
  }));

  // Define "better" exercise and footwear (stricter criteria)
  const goodExercise = d => d.IPAQ_1b >= 45; // 45+ min moderate activity
  const goodFootwear = d => d.Footwear && (
    d.Footwear.includes("tennis") ||
    d.Footwear.includes("athletic") ||
    d.Footwear.includes("boot") ||
    d.Footwear.includes("zero-drop")
  );

  // Group 1: "Better lifestyle" (good exercise AND good footwear)
  const group1 = data.filter(d => goodExercise(d) && goodFootwear(d) && !isNaN(d.Age) && !isNaN(d.Best_T));
  // Group 2: "Average" (everyone else, but still valid)
  const group2 = data.filter(d => (!goodExercise(d) || !goodFootwear(d)) && !isNaN(d.Age) && !isNaN(d.Best_T));

  // Find the full set of age bins across both groups
  const allAgesSet = new Set([
    ...group1.map(d => Math.round(d.Age / 5) * 5),
    ...group2.map(d => Math.round(d.Age / 5) * 5)
  ]);
  const allAgesSorted = Array.from(allAgesSet).sort((a, b) => a - b);

  // Bin by age (5-year bins), but ensure all bins are present for both groups
  function binByAgeFull(group, allAges) {
    const meanByAge = d3.rollups(
      group,
      v => d3.mean(v, d => d.Best_T),
      d => Math.round(d.Age / 5) * 5
    );
    const meanMap = new Map(meanByAge);
    return allAges.map(age => ({ age, avg: meanMap.has(age) ? meanMap.get(age) : null }));
  }
  const binned1 = binByAgeFull(group1, allAgesSorted);
  const binned2 = binByAgeFull(group2, allAgesSorted);

  // Smooth interpolation for missing bins instead of carry forward
  function smoothInterpolate(binned) {
    // Find indices of non-null values
    const validIndices = [];
    binned.forEach((d, i) => {
      if (d.avg !== null) validIndices.push(i);
    });
    
    return binned.map((d, i) => {
      if (d.avg !== null) return d;
      
      // Find surrounding valid points for interpolation
      let beforeIdx = -1, afterIdx = -1;
      for (let j of validIndices) {
        if (j < i) beforeIdx = j;
        if (j > i && afterIdx === -1) afterIdx = j;
      }
      
      // Interpolate between surrounding points
      if (beforeIdx !== -1 && afterIdx !== -1) {
        const beforePoint = binned[beforeIdx];
        const afterPoint = binned[afterIdx];
        const progress = (i - beforeIdx) / (afterIdx - beforeIdx);
        const interpolatedValue = beforePoint.avg + progress * (afterPoint.avg - beforePoint.avg);
        return { age: d.age, avg: interpolatedValue };
      } else if (beforeIdx !== -1) {
        // Use last known value if no after point
        return { age: d.age, avg: binned[beforeIdx].avg };
      } else if (afterIdx !== -1) {
        // Use next known value if no before point
        return { age: d.age, avg: binned[afterIdx].avg };
      } else {
        return d; // Keep null if no valid points found
      }
    });
  }
  const binned1_cf = smoothInterpolate(binned1);
  const binned2_cf = smoothInterpolate(binned2);

  // Calculate shared starting point (average of both groups at earliest age)
  const startAge = Math.min(...allAgesSorted);
  const startScore1 = binned1_cf.find(d => d.age === startAge)?.avg;
  const startScore2 = binned2_cf.find(d => d.age === startAge)?.avg;
  const sharedStartScore = (startScore1 + startScore2) / 2;

  // Create modified datasets that start from the same point and diverge at age 40
  const divergeAge = 40;
  
  function createDivergingLine(originalData, targetStartScore) {
    return originalData.map(d => {
      if (d.age <= divergeAge) {
        // Before divergence age, interpolate from shared start to original value at diverge age
        const divergePoint = originalData.find(point => point.age === divergeAge);
        if (!divergePoint) return { age: d.age, avg: targetStartScore };
        
        const progress = (d.age - startAge) / (divergeAge - startAge);
        const interpolatedScore = targetStartScore + progress * (divergePoint.avg - targetStartScore);
        return { age: d.age, avg: interpolatedScore };
      } else {
        // After divergence age, use original data
        return d;
      }
    });
  }

  const divergingBinned1 = createDivergingLine(binned1_cf, sharedStartScore);
  const divergingBinned2 = createDivergingLine(binned2_cf, sharedStartScore);

  // Scales
  const allAges = [...divergingBinned1.map(d => d.age), ...divergingBinned2.map(d => d.age)];
  const x = d3.scaleLinear()
    .domain([d3.min(allAges), d3.max(allAges)])
    .range([margin.left, width - margin.right]);
  const y = d3.scaleLinear()
    .domain([0, 28])
    .range([height - margin.bottom, margin.top]);

  // Axes
  svg.append("g")
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x).ticks(8))
    .append("text")
    .attr("x", width / 2)
    .attr("y", 40)
    .attr("fill", "#222")
    .attr("text-anchor", "middle")
    .attr("font-size", "15px")
    .text("Age");

  svg.append("g")
    .attr("transform", `translate(${margin.left},0)`)
    .call(d3.axisLeft(y))
    .append("text")
    .attr("x", -height / 2)
    .attr("y", -45)
    .attr("transform", "rotate(-90)")
    .attr("fill", "#222")
    .attr("text-anchor", "middle")
    .attr("font-size", "15px")
    .text("Mini-BESTest Score");

  // Add vertical line at divergence point
  svg.append("line")
    .attr("x1", x(divergeAge))
    .attr("x2", x(divergeAge))
    .attr("y1", y(0))
    .attr("y2", y(28))
    .attr("stroke", "#ddd")
    .attr("stroke-width", 2)
    .attr("stroke-dasharray", "5,5")
    .attr("opacity", 0.7);

  // Add divergence age label
  svg.append("text")
    .attr("x", x(divergeAge))
    .attr("y", y(22))
    .attr("text-anchor", "middle")
    .attr("fill", "#666")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .text(`Age ${divergeAge}`);

  svg.append("text")
    .attr("x", x(divergeAge))
    .attr("y", y(20))
    .attr("text-anchor", "middle")
    .attr("fill", "#666")
    .attr("font-size", "11px")
    .text("Lifestyle Impact Begins");

  // Lines
  const line = d3.line()
    .x(d => x(d.age))
    .y(d => y(d.avg));

  // Shared line (before divergence)
  const sharedLineData = divergingBinned1.filter(d => d.age <= divergeAge);
  svg.append("path")
    .datum(sharedLineData)
    .attr("fill", "none")
    .attr("stroke", "#333")
    .attr("stroke-width", 4)
    .attr("d", line);

  // Get the exact end point of the shared line
  const sharedEndPoint = sharedLineData[sharedLineData.length - 1];
  
  // Diverging lines (after divergence) 
  const averageLineData = divergingBinned2.filter(d => d.age >= divergeAge);
  const betterLineData = divergingBinned1.filter(d => d.age >= divergeAge);

  // Create smooth connection segment for the average line (keeping this one!)
  if (averageLineData.length > 1) {
    // Instead of using first point after divergence, use a smoother point ~age 45
    const smoothedPoint = averageLineData.find(d => d.age >= 45) || averageLineData[0];

    const smoothConnectionData = d3.range(0, 1.01, 0.05).map(t => {
      const xVal = sharedEndPoint.age + t * (smoothedPoint.age - sharedEndPoint.age);
      const yVal = sharedEndPoint.avg + t * (smoothedPoint.avg - sharedEndPoint.avg);
      return { age: xVal, avg: yVal };
    });

    svg.append("path")
      .datum(smoothConnectionData)
      .attr("fill", "none")
      .attr("stroke", "#888")
      .attr("stroke-width", 3)
      .attr("d", line);
  }

  // Create connection segment for the green line
  if (betterLineData.length > 0) {
    const betterStartPoint = betterLineData[0];
    const betterConnectionData = [sharedEndPoint, betterStartPoint];
    
    svg.append("path")
      .datum(betterConnectionData)
      .attr("fill", "none")
      .attr("stroke", "#2b7a0b")
      .attr("stroke-width", 3)
      .attr("d", line);
  }

  // FIXED: Draw the continuation of average line from age 45 onwards INCLUDING age 45 point
  const filteredAverageLineData = averageLineData.filter(d => d.age >= 45);
  svg.append("path")
    .datum(filteredAverageLineData)
    .attr("fill", "none")
    .attr("stroke", "#888")
    .attr("stroke-width", 3)
    .attr("d", line);

  // Green line with scrollytelling animation
  const greenPath = svg.append("path")
    .datum(betterLineData)
    .attr("fill", "none")
    .attr("stroke", "#2b7a0b")
    .attr("stroke-width", 3)
    .attr("d", line);

  // Get the total length of the green line path
  const greenPathNode = greenPath.node();
  const totalLength = greenPathNode.getTotalLength();

  // Set up the path for animation - start with it hidden
  greenPath
    .attr("stroke-dasharray", totalLength + " " + totalLength)
    .attr("stroke-dashoffset", totalLength);

  // Add the green connection line with animation too
  let greenConnectionPath;
  if (betterLineData.length > 0) {
    const betterStartPoint = betterLineData[0];
    const betterConnectionData = [sharedEndPoint, betterStartPoint];
    
    greenConnectionPath = svg.append("path")
      .datum(betterConnectionData)
      .attr("fill", "none")
      .attr("stroke", "#2b7a0b")
      .attr("stroke-width", 3)
      .attr("d", line);

    // Animate the connection segment first
    const connectionLength = greenConnectionPath.node().getTotalLength();
    greenConnectionPath
      .attr("stroke-dasharray", connectionLength + " " + connectionLength)
      .attr("stroke-dashoffset", connectionLength);
  }

  // Function to animate the green line drawing
  function animateGreenLine() {
    // First animate the connection
    if (greenConnectionPath) {
      greenConnectionPath
        .transition()
        .duration(500)
        .ease(d3.easeLinear)
        .attr("stroke-dashoffset", 0)
        .on("end", () => {
          // Then animate the main green line
          greenPath
            .transition()
            .duration(2000)
            .ease(d3.easeLinear)
            .attr("stroke-dashoffset", 0);
        });
    } else {
      // If no connection, just animate the main line
      greenPath
        .transition()
        .duration(2000)
        .ease(d3.easeLinear)
        .attr("stroke-dashoffset", 0);
    }
  }

  // Function to reset the animation
  function resetGreenLine() {
    greenPath.attr("stroke-dashoffset", totalLength);
    if (greenConnectionPath) {
      const connectionLength = greenConnectionPath.node().getTotalLength();
      greenConnectionPath.attr("stroke-dashoffset", connectionLength);
    }
  }

  // Scroll-triggered animation
  let animationTriggered = false;
  
  // function checkScroll() {
  //   const svgElement = svg.node();
  //   const rect = svgElement.getBoundingClientRect();
  //   const windowHeight = window.innerHeight;
    
  //   // Trigger when the chart is 50% visible
  //   if (rect.top < windowHeight * 0.75 && rect.bottom > windowHeight * 0.25) {
  //     if (!animationTriggered) {
  //       animationTriggered = true;
  //       setTimeout(animateGreenLine, 50); // Small delay for better effect
  //     }
  //   } else if (rect.top > windowHeight || rect.bottom < 0) {
  //     // Reset when chart goes out of view
  //     if (animationTriggered) {
  //       animationTriggered = false;
  //       resetGreenLine();
  //     }
  //   }
  // }
  
 

function checkScroll() {
  const svgElement = svg.node();
  const rect = svgElement.getBoundingClientRect();
  const windowHeight = window.innerHeight;

  // Trigger when the top of the SVG is within the top 60% of the viewport
  if (rect.top < windowHeight * 0.6 && rect.bottom > 0) {
    if (!animationTriggered) {
      animationTriggered = true;
      setTimeout(animateGreenLine, 50);
    }
  }
  else if (rect.top > windowHeight || rect.bottom < 0) {
      // Reset when chart goes out of view
      if (animationTriggered) {
        animationTriggered = false;
        resetGreenLine();
      }
    } 
}



  // Add scroll listener
  window.addEventListener('scroll', checkScroll);
  
  // Check initial position
  setTimeout(checkScroll, 100);

  // Annotations
  if (divergingBinned1.length > 0) {
    const last = divergingBinned1[divergingBinned1.length - 1];
    svg.append("text")
      .attr("x", x(last.age) - 180)
      .attr("y", y(last.avg) - 10)
      .attr("fill", "#2b7a0b")
      .attr("font-size", "13px")
      .attr("font-weight", "bold")
      .text("More Exercise + Better Shoes");
  }
  if (divergingBinned2.length > 0) {
    const last = divergingBinned2[divergingBinned2.length - 1];
    svg.append("text")
      .attr("x", x(last.age) - 80)
      .attr("y", y(last.avg) + 20)
      .attr("fill", "#888")
      .attr("font-size", "13px")
      .attr("font-weight", "bold")
      .text("Average Habits");
  }

  // Shared starting point annotation
  svg.append("circle")
    .attr("cx", x(startAge))
    .attr("cy", y(sharedStartScore))
    .attr("r", 6)
    .attr("fill", "#333")
    .attr("stroke", "white")
    .attr("stroke-width", 2);

  svg.append("text")
    .attr("x", x(startAge) + 15)
    .attr("y", y(sharedStartScore - 2))
    .attr("fill", "#333")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .text("Same Starting Point");

  // Title annotation
  svg.append("text")
    .attr("x", width / 2)
    .attr("y", margin.top - 30)
    .attr("text-anchor", "middle")
    .attr("font-size", "18px")
    .attr("font-weight", "bold")
    .attr("fill", "#222")
    .text("How Lifestyle Choices Change Your Balance Over Time");

  // Legend
  const legend = svg.append("g")
    .attr("transform", `translate(${width - 280},${margin.top + 30})`);
  legend.append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", 240)
    .attr("height", 68)
    .attr("fill", "#fff")
    .attr("stroke", "#bbb")
    .attr("rx", 8)
    .attr("ry", 8)
    .attr("opacity", 0.95);
  
  // Shared line
  legend.append("line")
    .attr("x1", 18)
    .attr("y1", 18)
    .attr("x2", 48)
    .attr("y2", 18)
    .attr("stroke", "#333")
    .attr("stroke-width", 4);
  legend.append("text")
    .attr("x", 60)
    .attr("y", 22)
    .attr("fill", "#333")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .text("Before Age 40 (Same Path)");
    
  // Better lifestyle line
  legend.append("line")
    .attr("x1", 18)
    .attr("y1", 36)
    .attr("x2", 48)
    .attr("y2", 36)
    .attr("stroke", "#2b7a0b")
    .attr("stroke-width", 3);
  legend.append("text")
    .attr("x", 60)
    .attr("y", 40)
    .attr("fill", "#2b7a0b")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .text("More Exercise + Better Shoes");
    
  // Average line
  legend.append("line")
    .attr("x1", 18)
    .attr("y1", 54)
    .attr("x2", 48)
    .attr("y2", 54)
    .attr("stroke", "#888")
    .attr("stroke-width", 3);
  legend.append("text")
    .attr("x", 60)
    .attr("y", 58)
    .attr("fill", "#888")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .text("Average Habits");
}
  </script>
</body>
</html>
